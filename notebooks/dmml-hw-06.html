<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-10-02">

<title>DMML-HW-06</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2" crossorigin="anonymous"></script><script src="dmml-hw-06_files/libs/clipboard/clipboard.min.js"></script>
<script src="dmml-hw-06_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="dmml-hw-06_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="dmml-hw-06_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="dmml-hw-06_files/libs/quarto-html/popper.min.js"></script>
<script src="dmml-hw-06_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="dmml-hw-06_files/libs/quarto-html/anchor.min.js"></script>
<link href="dmml-hw-06_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="dmml-hw-06_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="dmml-hw-06_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="dmml-hw-06_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="dmml-hw-06_files/libs/bootstrap/bootstrap-3fb89fd559c544a3aa8d65adba3e84d6.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js" integrity="sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-7K94V9Q0G8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-7K94V9Q0G8');
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">DMML-HW-06</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 2, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#modellek-összehasonlítása" id="toc-modellek-összehasonlítása" class="nav-link active" data-scroll-target="#modellek-összehasonlítása">Modellek összehasonlítása</a>
  <ul class="collapse">
  <li><a href="#kódstruktúra" id="toc-kódstruktúra" class="nav-link" data-scroll-target="#kódstruktúra">Kódstruktúra</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="dmml-hw-06.ipynb" download="dmml-hw-06.ipynb"><i class="bi bi-journal-code"></i>Jupyter</a></li></ul></div></nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><strong>Honlap:</strong> <a href="https://apagyidavid.web.elte.hu/2025-2026-1/dmml" target="_blank">apagyidavid.web.elte.hu/2025-2026-1/dmml</a></p>
<p><a target="_blank" href="https://colab.research.google.com/github/dapagyi/dmml-web/blob/gh-pages/notebooks/dmml-hw-06.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a></p>
<section id="modellek-összehasonlítása" class="level1">
<h1>Modellek összehasonlítása</h1>
<div class="callout callout-style-default callout-note callout-titled" title="Tanulási cél">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Tanulási cél
</div>
</div>
<div class="callout-body-container callout-body">
<p>A feladat elsődleges célja az, hogy egyfajta tech demoként kipróbáljunk minél többféle eszközt, illetve csomagot, amelyek később hasznosak lehetnek, valamint legyen egy stabil képünk arról, hogy hogyan lehet mérni és összehasonlítani különböző modellek teljesítményét.</p>
<p>A másodlagos cél az, hogy törekedjünk a kódunk minél jobb szervezésére, hogy ne kelljen sokat ismételgetni, illetve kínlódni a kód újrahasznosításával.</p>
<p>Nem cél, hogy jó eredményt érjünk el, de persze lehet rá törekedni. Nem kell érteni, hogy miről szól az adathalmaz, amivel dolgozunk. Nem kell EDA-t végezni sem.</p>
</div>
</div>
<p>Keress az interneten egy tetszőleges nyilvános (bináris vagy multi label) klasszifikációs adathalmazt – <a href="https://scikit-learn.org/stable/datasets.html" target="_blank">például innen is választhatsz, illetve generálhatsz egyet magadnak</a> –, amelyen nem vagy alig kell csak előfeldolgozást végezni, és lehetőleg nem túl kicsi.</p>
<p>Válassz le egy teszt adathalmazt, pl. az adatok 20%-t (<a href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" target="_blank"><code>train_test_split</code></a>).</p>
<p>A maradékon taníts be három különböző modellt:</p>
<ul>
<li>Az egyik legyen egy decision tree vagy egy random forest.</li>
<li>A másik kettő legyen egy-egy boosting modell, de ne a <code>scikit-learn</code>-ből. (Ld. az órai Notebookban szereplő hivatkozásokat.)</li>
</ul>
<p>Validáláshoz legalább egy (de akár az összes) esetben végezz keresztvalidációt. (A másik, egyszerűbb módszer az lenne, hogy a tanító adathalmazt is felosztod egy tanító és egy validációs halmazra (ugyanúgy <code>train_test_split</code>-tel), és a validációs halmazon méred a modelltanítási kísérletek eredményét.)</p>
<p>A hiperparaméter-optimalizáláshoz <del>legalább egy esetben</del> <em>opcionálisan</em> (frissítve: október 9.) próbáld ki az előző óra végén említett <a href="https://optuna.readthedocs.io/en/stable/tutorial/index.html" target="_blank">Optuna csomagot</a>.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Megjegyzés">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Megjegyzés
</div>
</div>
<div class="callout-body-container callout-body">
<p>A keresztvalidációt és a hiperparaméter-optimalizálás kapcsán fontos tisztázni egy részletet, ami felett gyakran szokás átsiklani, pedig bizonyos esetekben problémákhoz vezethet (konkrétan data leakage-hez, vagy legalábbis túlzottan optimista becsléshez a modell teljesítményét illetően).</p>
<p>Amikor pl. <span class="math inline">k</span>-foldot használunk a hiperparaméter-optimalizálás során, akkor annak a foldjai nem feltétlenül használhatóak közvetlenül a modell teljesítményének mérésére, ezért érdemes lehet egy külső <span class="math inline">k</span>-foldot is használni, amelynek a foldjain mérjük a modell teljesítményét.</p>
<ul>
<li><a href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_nested_cross_validation_iris.html#sphx-glr-auto-examples-model-selection-plot-nested-cross-validation-iris-py" target="_blank">Example (<code>scikit-learn</code>): Nested versus non-nested cross-validation</a></li>
</ul>
<p>Ez <em>opcionális</em>, de akinek jól mentek a korábbi dolgok, annak mindenképpen érdemes a fenti linket legalább elolvasnia, és felhasználni a feladat megoldásához is.</p>
</div>
</div>
<p>Az, hogy milyen metrika mentén optimalizálsz, rád van bízva, de a modell kiértékeléséhez tüntess fel minél többféle metrikát is (pl. accuracy, precision, recall, F1-score, ROC AUC stb.), valamint ábrázolj modellenként egy-egy confusion matrixot és ROC görbét is a teszt adathalmazon kiértékelve a modellt.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Megjegyzés">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Megjegyzés
</div>
</div>
<div class="callout-body-container callout-body">
<p>A több metrika szerinti kiértékelés könnyen megvalósítható például az alábbi módon:</p>
<ul>
<li><a href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_multi_metric_evaluation.html" target="_blank">Example (<code>scikit-learn</code>): Demonstration of multi-metric evaluation on <code>cross_val_score</code> and <code>GridSearchCV</code></a></li>
</ul>
</div>
</div>
<p>A megoldásod végén gyűjtsd össze egy DateFrame-ben vagy akár csak printeld ki összesítve a három modell (hiperparaméter-optimalizálás utáni) teljesítményét:</p>
<ul>
<li>A tanító teljesítmény többféle metrika mentén.
<ul>
<li>Ha keresztvalidációt használsz az adott modell kiértékelésére, akkor a foldokon mért teljesítmények átlaga és szórása. Ha hold-out validációt használsz, akkor csak egyetlen szám (metrikánként).</li>
</ul></li>
<li>A validációs teljesítmény többféle metrika mentén.
<ul>
<li>Ha keresztvalidációt használsz az adott modell kiértékelésére, akkor a foldokon mért teljesítmények átlaga és szórása.</li>
<li>Ez írja le legjobban a modellünk teljesítményét.</li>
</ul></li>
<li>A teszt adathalmazon mért teljesítmény többféle metrika mentén.
<ul>
<li>Ez teljesen különálló halmazon történik, és csak a végén nézzük meg.</li>
<li>Csak egyetlen szám (metrikánként), nem annyira robosztus, mint pl. egy keresztvalidációs mért teljesítmény.</li>
<li>Ez egyrészt egy végső sanity check, hogy hasonló eredményt kapunk-e, mint a validációkor, másrészt azt szimulálja, mintha pl. Kaggle-ön csak egy végső score-t hajkurásznánk.</li>
<li>Ábrázold a confusion matrixot és a ROC görbét is.</li>
</ul></li>
</ul>
<section id="kódstruktúra" class="level2">
<h2 class="anchored" data-anchor-id="kódstruktúra">Kódstruktúra</h2>
<p>Ez egy elég általános tanács, de ahhoz, hogy ne kelljen sokat ismételgetni, copy-paste-elni a kódokat, próbáld meg az egyes lépéseket egy-egy függvénybe szervezni, és a függvényeket meghívni. Használj loopokat, és pl. csak iterálj végig a modelleken, mindegyikre meghívva ugyanazokat a függvényeket, stb.</p>
<p>(Ld. még: szoftverfejlesztők összes bullshit akronimja, pl.: <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank">DRY</a>, <a href="https://en.wikipedia.org/wiki/KISS_principle" target="_blank">KISS</a>, <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it" target="_blank">YAGNI</a> stb.)</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Egy specifikusabb tanács">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Egy specifikusabb tanács
</div>
</div>
<div class="callout-body-container callout-body">
<p>Gyakran egy adaton ugyanazon változásokat hajtjuk végre, ezeket egy jól kezelhető egységbe zárhatjuk a <code>scikit-learn</code> pipeline modulja segítségével. Ez nemcsak az adatelőkészítést teszi könnyebbé, hanem a modelltanítást, hiperparaméter-optimalizálást is.</p>
<ul>
<li><a href="https://scikit-learn.org/stable/modules/compose.html#combining-estimators" target="_blank">User Guide (<code>scikit-learn</code>): Pipelines and composite estimators</a></li>
<li><a href="https://scikit-learn.org/stable/auto_examples/compose/index.html" target="_blank">Examples (˙scikit-learn`): Pipelines and composite estimators</a></li>
</ul>
<p>Hasznos eszköz, érdemes használni, én személyesen nagyon szeretem.</p>
<p>Akinek az alapok megvannak, az mindenképpen próbálja ki, de ez <em>opcionális</em> része a feladatnak.</p>
</div>
</div>
<p>Végül egy gyakorlatiasabb tanács: Kaggle-ön gyakran meg lehet nézni a versenyek győzteseinek a megoldásait. Ezek nagyon sokszor abból állnak, hogy spamelik a modelleket, és a sok modellből állítanak elő egy ensemble modellt. Ilyen példákból is sokszor el lehet lesni ötleteket, hogy mások hogyan struktúrálják a kódjukat.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Kiegészítő olvasmányok">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Kiegészítő olvasmányok
</div>
</div>
<div class="callout-body-container callout-body">
<p>Az alábbi néhány példa arról szól, hogy hogyan lehet még “fejleszteni” a ROC görbe ábrázolásán pl. az egyes foldok eredményeinek feltüntetésével, illetve multi label klasszifikáció esetén milyen hasonló dolgot lehet csinálni:</p>
<ul>
<li><a href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_roc_crossval.html" target="_blank">Receiver Operating Characteristic (ROC) with cross validation</a></li>
<li><a href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_roc.html" target="_blank">Multiclass Receiver Operating Characteristic (ROC)</a></li>
</ul>
<p><em>Opcionális</em> része a feladatnak az első reprodukálása a házi feladatban elkészített modellek valamelyikével. (Az alapfeladatban a teszt adathalmazon csak egy ROC görbe van, a validációson lehet azt megcsinálni, mint az első linken.)</p>
<p>Ez már egyáltalán nem része opcionálisan sem a feladatnak, de akit érdekel, annak érdemes lehet megnézni a következő példát, hogy hogyan lehet statisztikai alapon (kétféle megközelítéssel) összehasonlítani két modell teljesítményét:</p>
<ul>
<li><a href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_grid_search_stats.html" target="_blank">Statistical comparison of models using grid search</a></li>
</ul>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled" title="Útmutatás">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Útmutatás
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Én példaképpen az alábbi egyetemista szellemiségű adathalmazt választottam:</p>
<ul>
<li><a href="https://www.kaggle.com/datasets/fatemehmehrparvar/liver-disorders/data" target="_blank">Liver Disorders: Liver Cirrhosis and Healthy Liver Prediction</a></li>
</ul>
<p>Ehhez először megnéztem a feladat elején lévő scikit-learnös linket, majd rájöttem, hogy amit szerettem volna adathalmaz (Housing Dataset), az regressziós feladat, és a házit klasszifikációs problémaként írtam ki. Hát nem segítettem ki magamat.</p>
<p>Google-ön kerestem tovább (“common datasets for classification” kulcsszóval), megnéztem néhány ismerős Kaggle linket, összesítő GitHub repót, stb. Végül megtaláltam a fenti adathalmazt, ami:</p>
<ul>
<li>aránylag egyszerű,</li>
<li>nem túl nagy (kb. 600 sor),</li>
<li>főként numerikus feature-öket tartalmaz,</li>
<li>bináris klasszifikációs feladatról szól.</li>
</ul>
<p>Ránéztem néhány Kaggle-ös notebookra is, hogy mire számíthatok, és kb. okénak tűnt.</p>
<p>A célnak most megfelel.</p>
<p>EDA nem része a feladatnak, de minimálisan azért megnézem, hogy mivel lehet szükséges foglalkoznom. Most <code>polars</code>-t fogok használni, mert annyira nem vagyok járatos benne, és szeretném próbálgatni, <code>pandas</code>-hoz azonban több elérhető online anyag van, így talán az kezdőbarátabb.</p>
<div id="ba756cc5" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> polars <span class="im">as</span> pl</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pl.read_csv(<span class="st">"../data/liver_disorders.csv"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Shape: </span><span class="sc">{</span>df<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Duplicates: </span><span class="sc">{</span>df<span class="sc">.</span>is_duplicated()<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.unique()</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Shape (after removing duplicates): </span><span class="sc">{</span>df<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Shape: (583, 11)
Duplicates: 26
Shape (after removing duplicates): (570, 11)</code></pre>
</div>
</div>
<p>Volt pár duplikátum, amiket töröltem. Ezeknél valószínűbbnek tűnt az, hogy valami hibából kerültek be, mintsem hogy bármi különösebb jelentőségük lenne, pl. hogy pont ugyanolyan paraméterekkel rendelkező emberek volnának. (De nem olvastam utána – Kaggle-ön a Discussion oldalon gyakran találni ilyen infókat.)</p>
<p>Ennél többet már nem csinálok az adattal, nehogy esetleg valami data leakage-et okozzak. Még megnézek valamit, de már nem módosítok az adaton globálisan; máris leválasztom a teszt halmazt – ráadásul úgy, hogy biztosan hasonló arányban legyenek a címkék a train és a test halmazban is (<code>stratify</code> paraméter).</p>
<div id="eb02f23c" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>train_df, test_df <span class="op">=</span> train_test_split(df, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">42</span>, stratify<span class="op">=</span>df[<span class="st">"Selector"</span>])</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Train shape: </span><span class="sc">{</span>train_df<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">, Test shape: </span><span class="sc">{</span>test_df<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(train_df[<span class="st">"Selector"</span>].value_counts())</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(test_df[<span class="st">"Selector"</span>].value_counts())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Train shape: (456, 11), Test shape: (114, 11)
shape: (2, 2)
┌──────────┬───────┐
│ Selector ┆ count │
│ ---      ┆ ---   │
│ i64      ┆ u32   │
╞══════════╪═══════╡
│ 1        ┆ 325   │
│ 2        ┆ 131   │
└──────────┴───────┘
shape: (2, 2)
┌──────────┬───────┐
│ Selector ┆ count │
│ ---      ┆ ---   │
│ i64      ┆ u32   │
╞══════════╪═══════╡
│ 2        ┆ 33    │
│ 1        ┆ 81    │
└──────────┴───────┘</code></pre>
</div>
</div>
<p>Hiányzó értékek vannak esetleg?</p>
<div id="bab1ec2e" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.null_count())</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>df.<span class="bu">filter</span>(pl.any_horizontal(pl.<span class="bu">all</span>().is_null()))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>shape: (1, 11)
┌─────┬────────┬─────┬─────┬───┬─────┬─────┬───────────┬──────────┐
│ Age ┆ Gender ┆ TB  ┆ DB  ┆ … ┆ TP  ┆ ALB ┆ A/G Ratio ┆ Selector │
│ --- ┆ ---    ┆ --- ┆ --- ┆   ┆ --- ┆ --- ┆ ---       ┆ ---      │
│ u32 ┆ u32    ┆ u32 ┆ u32 ┆   ┆ u32 ┆ u32 ┆ u32       ┆ u32      │
╞═════╪════════╪═════╪═════╪═══╪═════╪═════╪═══════════╪══════════╡
│ 0   ┆ 0      ┆ 0   ┆ 0   ┆ … ┆ 0   ┆ 0   ┆ 4         ┆ 0        │
└─────┴────────┴─────┴─────┴───┴─────┴─────┴───────────┴──────────┘</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="3">
<div><style>
.dataframe > thead > tr,
.dataframe > tbody > tr {
  text-align: right;
  white-space: pre-wrap;
}
</style>
<small>shape: (4, 11)</small>
<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th">Age</th>
<th data-quarto-table-cell-role="th">Gender</th>
<th data-quarto-table-cell-role="th">TB</th>
<th data-quarto-table-cell-role="th">DB</th>
<th data-quarto-table-cell-role="th">Alkphos</th>
<th data-quarto-table-cell-role="th">Sgpt</th>
<th data-quarto-table-cell-role="th">Sgot</th>
<th data-quarto-table-cell-role="th">TP</th>
<th data-quarto-table-cell-role="th">ALB</th>
<th data-quarto-table-cell-role="th">A/G Ratio</th>
<th data-quarto-table-cell-role="th">Selector</th>
</tr>
<tr class="even">
<td>i64</td>
<td>str</td>
<td>f64</td>
<td>f64</td>
<td>i64</td>
<td>i64</td>
<td>i64</td>
<td>f64</td>
<td>f64</td>
<td>f64</td>
<td>i64</td>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>51</td>
<td>"Male"</td>
<td>0.8</td>
<td>0.2</td>
<td>230</td>
<td>24</td>
<td>46</td>
<td>6.5</td>
<td>3.1</td>
<td>null</td>
<td>1</td>
</tr>
<tr class="even">
<td>35</td>
<td>"Female"</td>
<td>0.6</td>
<td>0.2</td>
<td>180</td>
<td>12</td>
<td>15</td>
<td>5.2</td>
<td>2.7</td>
<td>null</td>
<td>2</td>
</tr>
<tr class="odd">
<td>27</td>
<td>"Male"</td>
<td>1.3</td>
<td>0.6</td>
<td>106</td>
<td>25</td>
<td>54</td>
<td>8.5</td>
<td>4.8</td>
<td>null</td>
<td>2</td>
</tr>
<tr class="even">
<td>45</td>
<td>"Female"</td>
<td>0.9</td>
<td>0.3</td>
<td>189</td>
<td>23</td>
<td>33</td>
<td>6.6</td>
<td>3.9</td>
<td>null</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>Négy hiányzó érték nem túl jelentős szerencsére. Az “A/G Ratio” egy vérvizsgálati eredmény. Egyelőre nem tudok róla sokat, de megnézem, hogy milyen értékeket vesz fel másoknál.</p>
<div id="a9a03928" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>sns.histplot(df, x<span class="op">=</span><span class="st">"A/G Ratio"</span>, hue<span class="op">=</span><span class="st">"Selector"</span>, palette<span class="op">=</span><span class="st">"colorblind"</span>, kde<span class="op">=</span><span class="va">True</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="dmml-hw-06_files/figure-html/cell-6-output-1.png" width="585" height="429" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Ezt a négy hiányzó értéket kitöltöm majd a feature mediánjával.</p>
<p>Mi a helyzet a többi feature eloszlásával?</p>
<div id="0eea53d9" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>sns.pairplot(df.to_pandas(), hue<span class="op">=</span><span class="st">"Selector"</span>, corner<span class="op">=</span><span class="va">True</span>, palette<span class="op">=</span><span class="st">"colorblind"</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">"Numerical Features"</span>, y<span class="op">=</span><span class="fl">1.02</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="dmml-hw-06_files/figure-html/cell-7-output-1.png" width="2209" height="2194" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Néhány oszlop eloszlásának elég hosszú a farka, ezeknek más esetben érdemes lehetne a logaritmusát venni, hogy kezelhetőbbé váljanak, de a fa alapú modellek erre nem érzékenyek. (<em>Gondoljuk meg, hogy ez mit jelenthet, illetve hogy miért lehet ez.</em>)</p>
<p>A fentiek után elkezdtem összerakni a kódot apránként egy külön fájlban. Közel sincs kész, de aránylag könnyen folytatható. Amikor már elég sok modellből áll a megoldás, biztos refaktorálnám még, hogy kevesebb legyen a kódismétlés, mert jelenleg elég sok boilerplate van.</p>
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>dmml-hw-06-guidance.py</strong></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9" data-filename="dmml-hw-06-guidance.py"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> optuna</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> polars <span class="im">as</span> pl</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.base <span class="im">import</span> BaseEstimator</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.compose <span class="im">import</span> ColumnTransformer</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.ensemble <span class="im">import</span> RandomForestClassifier</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.impute <span class="im">import</span> SimpleImputer</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> classification_report, f1_score, roc_auc_score</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> (</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    RandomizedSearchCV,</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    StratifiedKFold,</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    cross_val_score,</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    cross_validate,</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    train_test_split,</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> Pipeline</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> OneHotEncoder</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_pipeline_from_classifier(clf: BaseEstimator) <span class="op">-&gt;</span> Pipeline:</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    pipeline <span class="op">=</span> Pipeline(</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        steps<span class="op">=</span>[</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>            (</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>                <span class="st">"preprocessor"</span>,</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>                ColumnTransformer(</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>                    transformers<span class="op">=</span>[</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>                        (<span class="st">"ag_ratio"</span>, SimpleImputer(strategy<span class="op">=</span><span class="st">"median"</span>), [<span class="st">"A/G Ratio"</span>]),</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>                        (<span class="st">"gender"</span>, OneHotEncoder(handle_unknown<span class="op">=</span><span class="st">"ignore"</span>, drop<span class="op">=</span><span class="st">"first"</span>), [<span class="st">"Gender"</span>]),</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>                    ],</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>                    remainder<span class="op">=</span><span class="st">"passthrough"</span>,</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>                    verbose_feature_names_out<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>                ),</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>            ),</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>            (<span class="st">"model"</span>, clf),</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pipeline</span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> validate_model(</span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>    model: BaseEstimator,</span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>    X_train: pl.DataFrame,</span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>    y_train: pl.Series,</span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>    cv_number_of_splits: <span class="bu">int</span>,</span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>    random_state: <span class="bu">int</span>,</span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">dict</span>:</span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>    cv: StratifiedKFold <span class="op">=</span> StratifiedKFold(n_splits<span class="op">=</span>cv_number_of_splits, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span>random_state)</span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a>    scores <span class="op">=</span> cross_validate(</span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>        model,</span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a>        X_train,  <span class="co"># type: ignore</span></span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a>        y_train,</span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a>        cv<span class="op">=</span>cv,</span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a>        scoring<span class="op">=</span>[<span class="st">"roc_auc"</span>, <span class="st">"accuracy"</span>],</span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a>        return_train_score<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true" tabindex="-1"></a>        verbose<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb9-57"><a href="#cb9-57" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb9-58"><a href="#cb9-58" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Cross-validated ROC-AUC score: </span><span class="sc">{</span>scores[<span class="st">'test_roc_auc'</span>]<span class="sc">.</span>mean()<span class="sc">:.4f}</span><span class="ss"> ± </span><span class="sc">{</span>scores[<span class="st">'test_roc_auc'</span>]<span class="sc">.</span>std()<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb9-59"><a href="#cb9-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> scores</span>
<span id="cb9-60"><a href="#cb9-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-61"><a href="#cb9-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-62"><a href="#cb9-62" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate_model_on_test(model: BaseEstimator, X: pl.DataFrame, y_true: pl.Series) <span class="op">-&gt;</span> <span class="bu">dict</span>:</span>
<span id="cb9-63"><a href="#cb9-63" aria-hidden="true" tabindex="-1"></a>    scores <span class="op">=</span> {</span>
<span id="cb9-64"><a href="#cb9-64" aria-hidden="true" tabindex="-1"></a>        <span class="st">"roc_auc"</span>: roc_auc_score(y_true, model.predict_proba(X)[:, <span class="dv">1</span>]),  <span class="co"># type: ignore</span></span>
<span id="cb9-65"><a href="#cb9-65" aria-hidden="true" tabindex="-1"></a>        <span class="st">"accuracy"</span>: (y_true <span class="op">==</span> model.predict(X)).mean(),  <span class="co"># type: ignore</span></span>
<span id="cb9-66"><a href="#cb9-66" aria-hidden="true" tabindex="-1"></a>        <span class="st">"f1"</span>: f1_score(y_true, model.predict(X)),  <span class="co"># type: ignore</span></span>
<span id="cb9-67"><a href="#cb9-67" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-68"><a href="#cb9-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-69"><a href="#cb9-69" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Test ROC-AUC:"</span>, scores[<span class="st">"roc_auc"</span>])</span>
<span id="cb9-70"><a href="#cb9-70" aria-hidden="true" tabindex="-1"></a>    <span class="co"># print("Test Accuracy:", scores["accuracy"])</span></span>
<span id="cb9-71"><a href="#cb9-71" aria-hidden="true" tabindex="-1"></a>    <span class="co"># print("Test F1 Score:", scores["f1"])</span></span>
<span id="cb9-72"><a href="#cb9-72" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(classification_report(y_true, model.predict(X)))  <span class="co"># type: ignore</span></span>
<span id="cb9-73"><a href="#cb9-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-74"><a href="#cb9-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> scores</span>
<span id="cb9-75"><a href="#cb9-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-76"><a href="#cb9-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-77"><a href="#cb9-77" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> main() <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb9-78"><a href="#cb9-78" aria-hidden="true" tabindex="-1"></a>    RANDOM_STATE <span class="op">=</span> <span class="dv">42</span></span>
<span id="cb9-79"><a href="#cb9-79" aria-hidden="true" tabindex="-1"></a>    CV_FOLDS <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb9-80"><a href="#cb9-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-81"><a href="#cb9-81" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pl.read_csv(<span class="st">"./data/liver_disorders.csv"</span>)</span>
<span id="cb9-82"><a href="#cb9-82" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.unique()</span>
<span id="cb9-83"><a href="#cb9-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-84"><a href="#cb9-84" aria-hidden="true" tabindex="-1"></a>    X, y <span class="op">=</span> df.drop(<span class="st">"Selector"</span>), df[<span class="st">"Selector"</span>]</span>
<span id="cb9-85"><a href="#cb9-85" aria-hidden="true" tabindex="-1"></a>    X_train, X_test, y_train, y_test <span class="op">=</span> train_test_split(</span>
<span id="cb9-86"><a href="#cb9-86" aria-hidden="true" tabindex="-1"></a>        X.to_pandas(), y.to_pandas(), test_size<span class="op">=</span><span class="fl">0.4</span>, random_state<span class="op">=</span>RANDOM_STATE, stratify<span class="op">=</span>y</span>
<span id="cb9-87"><a href="#cb9-87" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb9-88"><a href="#cb9-88" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Train set size: </span><span class="sc">{</span>X_train<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">, Test set size: </span><span class="sc">{</span>X_test<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-89"><a href="#cb9-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-90"><a href="#cb9-90" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Unoptimized model for baseline</span></span>
<span id="cb9-91"><a href="#cb9-91" aria-hidden="true" tabindex="-1"></a>    clf <span class="op">=</span> RandomForestClassifier(random_state<span class="op">=</span>RANDOM_STATE)</span>
<span id="cb9-92"><a href="#cb9-92" aria-hidden="true" tabindex="-1"></a>    pipeline <span class="op">=</span> create_pipeline_from_classifier(clf)</span>
<span id="cb9-93"><a href="#cb9-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-94"><a href="#cb9-94" aria-hidden="true" tabindex="-1"></a>    _cv_scores <span class="op">=</span> validate_model(pipeline, X_train, y_train, CV_FOLDS, RANDOM_STATE)</span>
<span id="cb9-95"><a href="#cb9-95" aria-hidden="true" tabindex="-1"></a>    pipeline.fit(X_train, y_train)</span>
<span id="cb9-96"><a href="#cb9-96" aria-hidden="true" tabindex="-1"></a>    _test_scores <span class="op">=</span> evaluate_model_on_test(pipeline, X_test, y_test)</span>
<span id="cb9-97"><a href="#cb9-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-98"><a href="#cb9-98" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Hyperparameter tuning using RandomizedSearchCV</span></span>
<span id="cb9-99"><a href="#cb9-99" aria-hidden="true" tabindex="-1"></a>    clf <span class="op">=</span> RandomForestClassifier(random_state<span class="op">=</span>RANDOM_STATE)</span>
<span id="cb9-100"><a href="#cb9-100" aria-hidden="true" tabindex="-1"></a>    param_grid <span class="op">=</span> {</span>
<span id="cb9-101"><a href="#cb9-101" aria-hidden="true" tabindex="-1"></a>        <span class="st">"model__criterion"</span>: [<span class="st">"gini"</span>, <span class="st">"entropy"</span>],</span>
<span id="cb9-102"><a href="#cb9-102" aria-hidden="true" tabindex="-1"></a>        <span class="st">"model__max_depth"</span>: [<span class="va">None</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">15</span>, <span class="dv">20</span>],</span>
<span id="cb9-103"><a href="#cb9-103" aria-hidden="true" tabindex="-1"></a>        <span class="st">"model__n_estimators"</span>: scipy.stats.randint(<span class="dv">100</span>, <span class="dv">500</span>),</span>
<span id="cb9-104"><a href="#cb9-104" aria-hidden="true" tabindex="-1"></a>        <span class="st">"model__min_samples_split"</span>: [<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>],</span>
<span id="cb9-105"><a href="#cb9-105" aria-hidden="true" tabindex="-1"></a>        <span class="st">"model__min_samples_leaf"</span>: [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>],</span>
<span id="cb9-106"><a href="#cb9-106" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-107"><a href="#cb9-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-108"><a href="#cb9-108" aria-hidden="true" tabindex="-1"></a>    randomized_search_cv <span class="op">=</span> StratifiedKFold(n_splits<span class="op">=</span>CV_FOLDS, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span>RANDOM_STATE <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb9-109"><a href="#cb9-109" aria-hidden="true" tabindex="-1"></a>    randomized_search <span class="op">=</span> RandomizedSearchCV(</span>
<span id="cb9-110"><a href="#cb9-110" aria-hidden="true" tabindex="-1"></a>        create_pipeline_from_classifier(clf),</span>
<span id="cb9-111"><a href="#cb9-111" aria-hidden="true" tabindex="-1"></a>        param_grid,</span>
<span id="cb9-112"><a href="#cb9-112" aria-hidden="true" tabindex="-1"></a>        n_iter<span class="op">=</span><span class="dv">25</span>,</span>
<span id="cb9-113"><a href="#cb9-113" aria-hidden="true" tabindex="-1"></a>        cv<span class="op">=</span>randomized_search_cv,</span>
<span id="cb9-114"><a href="#cb9-114" aria-hidden="true" tabindex="-1"></a>        scoring<span class="op">=</span><span class="st">"roc_auc"</span>,</span>
<span id="cb9-115"><a href="#cb9-115" aria-hidden="true" tabindex="-1"></a>        verbose<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb9-116"><a href="#cb9-116" aria-hidden="true" tabindex="-1"></a>        n_jobs<span class="op">=-</span><span class="dv">1</span>,</span>
<span id="cb9-117"><a href="#cb9-117" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb9-118"><a href="#cb9-118" aria-hidden="true" tabindex="-1"></a>    randomized_search.fit(X_train, y_train)</span>
<span id="cb9-119"><a href="#cb9-119" aria-hidden="true" tabindex="-1"></a>    cv_df <span class="op">=</span> pl.DataFrame(randomized_search.cv_results_).sort(<span class="st">"rank_test_score"</span>)</span>
<span id="cb9-120"><a href="#cb9-120" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(</span>
<span id="cb9-121"><a href="#cb9-121" aria-hidden="true" tabindex="-1"></a>        <span class="ss">f"Randomized search CV - Cross-validated ROC-AUC score: </span><span class="sc">{</span>cv_df[<span class="st">'mean_test_score'</span>][<span class="dv">0</span>]<span class="sc">:.4f}</span><span class="ss"> ± </span><span class="sc">{</span>cv_df[<span class="st">'std_test_score'</span>][<span class="dv">0</span>]<span class="sc">:.4f}</span><span class="ss">"</span></span>
<span id="cb9-122"><a href="#cb9-122" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb9-123"><a href="#cb9-123" aria-hidden="true" tabindex="-1"></a>    _cv_scores <span class="op">=</span> validate_model(randomized_search.best_estimator_, X_train, y_train, CV_FOLDS, RANDOM_STATE)</span>
<span id="cb9-124"><a href="#cb9-124" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(randomized_search.best_params_)</span>
<span id="cb9-125"><a href="#cb9-125" aria-hidden="true" tabindex="-1"></a>    _test_scores <span class="op">=</span> evaluate_model_on_test(randomized_search.best_estimator_, X_test, y_test)</span>
<span id="cb9-126"><a href="#cb9-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-127"><a href="#cb9-127" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Hyperparameter tuning using Optuna</span></span>
<span id="cb9-128"><a href="#cb9-128" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> objective(trial: optuna.Trial) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb9-129"><a href="#cb9-129" aria-hidden="true" tabindex="-1"></a>        clf <span class="op">=</span> RandomForestClassifier(</span>
<span id="cb9-130"><a href="#cb9-130" aria-hidden="true" tabindex="-1"></a>            criterion<span class="op">=</span>trial.suggest_categorical(<span class="st">"criterion"</span>, [<span class="st">"gini"</span>, <span class="st">"entropy"</span>]),  <span class="co"># type: ignore</span></span>
<span id="cb9-131"><a href="#cb9-131" aria-hidden="true" tabindex="-1"></a>            max_depth<span class="op">=</span>trial.suggest_int(<span class="st">"max_depth"</span>, <span class="dv">5</span>, <span class="dv">25</span>, step<span class="op">=</span><span class="dv">5</span>),</span>
<span id="cb9-132"><a href="#cb9-132" aria-hidden="true" tabindex="-1"></a>            n_estimators<span class="op">=</span>trial.suggest_int(<span class="st">"n_estimators"</span>, <span class="dv">100</span>, <span class="dv">500</span>, step<span class="op">=</span><span class="dv">50</span>),</span>
<span id="cb9-133"><a href="#cb9-133" aria-hidden="true" tabindex="-1"></a>            min_samples_split<span class="op">=</span>trial.suggest_categorical(<span class="st">"min_samples_split"</span>, [<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>]),</span>
<span id="cb9-134"><a href="#cb9-134" aria-hidden="true" tabindex="-1"></a>            min_samples_leaf<span class="op">=</span>trial.suggest_categorical(<span class="st">"min_samples_leaf"</span>, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>]),</span>
<span id="cb9-135"><a href="#cb9-135" aria-hidden="true" tabindex="-1"></a>            random_state<span class="op">=</span>RANDOM_STATE,</span>
<span id="cb9-136"><a href="#cb9-136" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb9-137"><a href="#cb9-137" aria-hidden="true" tabindex="-1"></a>        pipeline <span class="op">=</span> create_pipeline_from_classifier(clf)</span>
<span id="cb9-138"><a href="#cb9-138" aria-hidden="true" tabindex="-1"></a>        scores <span class="op">=</span> cross_val_score(</span>
<span id="cb9-139"><a href="#cb9-139" aria-hidden="true" tabindex="-1"></a>            pipeline,</span>
<span id="cb9-140"><a href="#cb9-140" aria-hidden="true" tabindex="-1"></a>            X_train,</span>
<span id="cb9-141"><a href="#cb9-141" aria-hidden="true" tabindex="-1"></a>            y_train,</span>
<span id="cb9-142"><a href="#cb9-142" aria-hidden="true" tabindex="-1"></a>            cv<span class="op">=</span>StratifiedKFold(n_splits<span class="op">=</span>CV_FOLDS, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span>RANDOM_STATE <span class="op">+</span> <span class="dv">1</span>),</span>
<span id="cb9-143"><a href="#cb9-143" aria-hidden="true" tabindex="-1"></a>            scoring<span class="op">=</span><span class="st">"roc_auc"</span>,</span>
<span id="cb9-144"><a href="#cb9-144" aria-hidden="true" tabindex="-1"></a>            n_jobs<span class="op">=-</span><span class="dv">1</span>,</span>
<span id="cb9-145"><a href="#cb9-145" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb9-146"><a href="#cb9-146" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> scores.mean()</span>
<span id="cb9-147"><a href="#cb9-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-148"><a href="#cb9-148" aria-hidden="true" tabindex="-1"></a>    optuna.logging.set_verbosity(optuna.logging.WARNING)</span>
<span id="cb9-149"><a href="#cb9-149" aria-hidden="true" tabindex="-1"></a>    study <span class="op">=</span> optuna.create_study(direction<span class="op">=</span><span class="st">"maximize"</span>)</span>
<span id="cb9-150"><a href="#cb9-150" aria-hidden="true" tabindex="-1"></a>    study.optimize(objective, n_trials<span class="op">=</span><span class="dv">25</span>)</span>
<span id="cb9-151"><a href="#cb9-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-152"><a href="#cb9-152" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Best hyperparameters found:"</span>)</span>
<span id="cb9-153"><a href="#cb9-153" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key, value <span class="kw">in</span> study.best_params.items():</span>
<span id="cb9-154"><a href="#cb9-154" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  </span><span class="sc">{</span>key<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>value<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-155"><a href="#cb9-155" aria-hidden="true" tabindex="-1"></a>    best_clf <span class="op">=</span> RandomForestClassifier(</span>
<span id="cb9-156"><a href="#cb9-156" aria-hidden="true" tabindex="-1"></a>        <span class="op">**</span>study.best_params,</span>
<span id="cb9-157"><a href="#cb9-157" aria-hidden="true" tabindex="-1"></a>        random_state<span class="op">=</span>RANDOM_STATE,</span>
<span id="cb9-158"><a href="#cb9-158" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb9-159"><a href="#cb9-159" aria-hidden="true" tabindex="-1"></a>    best_pipeline <span class="op">=</span> create_pipeline_from_classifier(best_clf)</span>
<span id="cb9-160"><a href="#cb9-160" aria-hidden="true" tabindex="-1"></a>    _cv_scores <span class="op">=</span> validate_model(best_pipeline, X_train, y_train, CV_FOLDS, RANDOM_STATE)</span>
<span id="cb9-161"><a href="#cb9-161" aria-hidden="true" tabindex="-1"></a>    best_pipeline.fit(X_train, y_train)</span>
<span id="cb9-162"><a href="#cb9-162" aria-hidden="true" tabindex="-1"></a>    _test_scores <span class="op">=</span> evaluate_model_on_test(best_pipeline, X_test, y_test)</span>
<span id="cb9-163"><a href="#cb9-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-164"><a href="#cb9-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-165"><a href="#cb9-165" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb9-166"><a href="#cb9-166" aria-hidden="true" tabindex="-1"></a>    main()</span>
<span id="cb9-167"><a href="#cb9-167" aria-hidden="true" tabindex="-1"></a></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Példa futtatás eredménye:</p>
<pre><code>david@david-thinkpad:~/code/dmml$ uv run notebooks/dmml-hw-06-guidance.py 
Train set size: 342, Test set size: 228
Cross-validated ROC-AUC score: 0.7020 ± 0.0298
Test ROC-AUC: 0.7116535727646839
              precision    recall  f1-score   support

           1       0.74      0.83      0.78       162
           2       0.42      0.30      0.35        66

    accuracy                           0.68       228
   macro avg       0.58      0.57      0.57       228
weighted avg       0.65      0.68      0.66       228

Fitting 5 folds for each of 25 candidates, totalling 125 fits
Randomized search CV - Cross-validated ROC-AUC score: 0.7178 ± 0.0515
Cross-validated ROC-AUC score: 0.7215 ± 0.0238
{'model__criterion': 'entropy', 'model__max_depth': 5, 'model__min_samples_leaf': 2, 'model__min_samples_split': 10, 'model__n_estimators': 396}
Test ROC-AUC: 0.7307332585110363
              precision    recall  f1-score   support

           1       0.73      0.94      0.82       162
           2       0.47      0.14      0.21        66

    accuracy                           0.71       228
   macro avg       0.60      0.54      0.52       228
weighted avg       0.65      0.71      0.64       228

Best hyperparameters found:
  criterion: entropy
  max_depth: 5
  n_estimators: 250
  min_samples_split: 10
  min_samples_leaf: 2
Cross-validated ROC-AUC score: 0.7222 ± 0.0255
Test ROC-AUC: 0.7300785634118967
              precision    recall  f1-score   support

           1       0.73      0.93      0.82       162
           2       0.48      0.15      0.23        66

    accuracy                           0.71       228
   macro avg       0.60      0.54      0.52       228
weighted avg       0.66      0.71      0.65       228
</code></pre>
</div>
</div>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>